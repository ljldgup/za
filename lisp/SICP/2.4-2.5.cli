;methods是关键字，就是用来管理函数映射的

(def method_map 
{'add {}, 
'sub {}, 
'mul {} 
'div {}
'make {}})

(defn attach_tag [t x]
    (cons t x))

(defn install_number []
    (defn tag[x]
        (attach_tag 'my_number (list x)))
    (assoc (method_map 'add) '(my_number my_number)
        (fn[x y] (tag (+ (second x) (second y)))))
    (assoc (method_map 'sub) '(my_number my_number)
        (fn[x y] (tag (- (second x) (second y)))))
    (assoc (method_map 'mul) '(my_number my_number)
        (fn[x y] (tag (* (second x) (second y)))))
    (assoc (method_map 'div) '(my_number my_number)
        (fn[x y] (tag (/ (second x) (second y)))))
    (assoc (method_map 'make) '(raw_number)
        (fn[x] (tag x))))
        
(defn install_complex_number []
    (defn tag
        [x, y] (attach_tag 'complex_number (list x y))
        [x] (attach_tag 'complex_number x))
        
    (defn real [complex_number]
        (nth complex_number 1))
        
    (defn image [complex_number]
        (nth complex_number 2))
        
    (defn add_complex_number [n1 n2]
        (tag 
            (+ (real n1) (real n2))
            (+ (image n1) (image n2))))
    (defn sub_complex_number [n1 n2]
        (tag 
            (- (real n1) (real n2))
            (- (image n1) (image n2))))

    (defn mul_complex_number [n1 n2]
        (tag 
            (- (* (real n1) (real n2)) (* (image n1) (image n2)))
            (+ (* (image n1) (real n2)) (* (image n2) (real n1)))))
            
     ;;复杂除法太复杂      
    (assoc (method_map 'add) '(complex_number complex_number) add_complex_number)
    (assoc (method_map 'sub) '(complex_number complex_number) sub_complex_number)
    (assoc (method_map 'mul) '(complex_number complex_number) mul_complex_number)
        
    (assoc (method_map 'make) '(raw_number)
        (fn[x] (tag x))))
;;因为clojure 参数不可变，method_map值不会变，用def双层map极其繁琐，且会有多线程问题，
;;这种做法无法实现。。

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;clojure 实现了defmulti defmethod 来进行函数派发
;defmulti 定义一个函数返回标志位，然后根据defmethod的同名过程进行选择
;实际使用一般标志位用，:开头关键字来实现，
(defn type_tag [x]
    (first x))
    
(defn attach_tag [t x]
    (cons t x))
    
(defn real [complex_number]
    (nth complex_number 1))
    
(defn image [complex_number]
    (nth complex_number 2))

;#()返回的会自动用括号包围
(defmulti add (fn[x y](println x y)(list (type_tag x) (type_tag y))))

(defmethod add '(my_number my_number) [x y] 
    (attach_tag 'my_number (list (+ (second x) (second y)))))
    
(defmethod add '(complex_number complex_number)[x y] 
    (attach_tag 'complex_number (list (+ (real x) (real y)) (+ (image x) (image y)))))
    
(defmethod add :default [args] (println args "is default"))


(defn make_my_number [x] (list 'my_number x))
(defn make_complex_number [x y] (list 'complex_number x y))

;;Wrong number of args (2) passed to: 出现这个错误救是没找到对应派发函数
(add (make_my_number 23)  (make_my_number 12))
(add (make_complex_number 23 12)  (make_complex_number 12 23))
(add '(my_number 1) '(my_number 1))
(add (list 'complex_number 23 12) (list 'complex_number 23 12))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmulti =zero? #(type_tag %))
(defmethod =zero? 'my_number [n] (= (second n) 0))
(defmethod =zero? 'complex_number [n] (and (= (real n) 0) (= (image n) 0)))
(=zero? (make_my_number 0))

(defmulti larger? #(list (type_tag %1) (type_tag %2)))
;;这里即使一个分发标志也要用括号包围, #()返回的会自动变成list
(defmethod larger? '(my_number my_number) [x y] (> (second x) (second y)))

(defn make_poly [v terms]
    (list 'polymonial v terms))

(defn get_order [term]
    (if (= (first term) 'term) (second term)))

(defn get_coeff [term]
    (if (= (first term) 'term) (nth term 2)))

(defn get_varible [p]
    (second p))

(defn make_term [c o]
    (list 'term c o))

(defn get_term_list [p]
    (nth p 2))

(defn empty_term_list? [term_list]
    (empty? term_list))
    
(defn first_term [term_list]
    (first term_list))
    
(defn same_varible? [p1 p2]
    (= (get_varible p1) (get_varible p2)))

(defn adjoin_term [term term_list]
    (println term term_list)
    (if (=zero? (get_coeff term))
        term_list
        (cons term term_list)))
    
(defn print_term[term]
    (print (format "%sx^%s" (get_coeff term) (get_order term))))
    
(defn print_term_list[term_list]
    (if (not (empty? list))
        (do
            (print_term (first term_list))
            (recur (rest term_list)))))

    
(defn add_terms [term_list1 term_list2]
    (println 'add_terms term_list1 term_list2)
    (cond 
        (empty_term_list? term_list1) term_list2
        (empty_term_list? term_list2) term_list1
        :else 
            (let [t1 (first term_list1), t2 (first term_list2)]
                (println 'add_terms_let t1 t2)
                (cond 
                    ;;复数这个>怎么定义？？     
                    (larger? (get_order t1) (get_order t2)) (adjoin_term t1 (add_terms (rest term_list1) term_list2))
                    (larger? (get_order t2) (get_order t1)) (adjoin_term t2 (add_terms (rest term_list2) term_list1))
                    :else (adjoin_term 
                            (make_term (get_order t1) (add (get_coeff t1) (get_coeff t2)))
                            (add_terms (rest term_list1) (rest term_list2)))))))
        
(defn add_poly [p1 p2]
    (if (same_varible? p1 p2)
        (make_poly (get_varible p1) (add_terms (get_term_list p1) (get_term_list p2)))))

;这里第一项幂指数要从大到小排序
(def poly1 
    (make_poly 'x 
        (list 
            (make_term (make_my_number 3) (make_my_number 2)) 
            (make_term (make_my_number 2) (make_my_number 1)))))
        
(def poly2 
    (make_poly 'x 
        (list 
            (make_term (make_my_number 4) (make_my_number 1)) 
            (make_term (make_my_number 3) (make_my_number 3)))))
            
(add_poly poly1 poly2)    